/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.28                          *
*        Compiled Jan 30 2015, 16:41:06                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"
#include "Func_for_GUI_Public.h"



static void  Fill_Table  (WM_HWIN hWin)  ; 
WM_HWIN Create_Framewin_Polling_Device_IO_Menu_in_Slave_Single ( uint32_t Adr );
//extern WM_HWIN CreateFramewinMenuDeviceTableofRespondDevMasterChangeStatKLAIADR (const uint32_t Adres);

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_FRAMEWIN_0    (GUI_ID_USER + 0x00)
#define ID_LISTVIEW_0    (GUI_ID_USER + 0x01)


// USER START (Optionally insert additional defines)
// USER END
//static FullAdressDev_t AdresGlAI; 
/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
// USER END
/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { FRAMEWIN_CreateIndirect, (const char *)&TextString345, ID_FRAMEWIN_0, 25,  25, 775, 455, 0, 0x0, 0 },  //"Управление.таблица устройств.ИУ"
  { LISTVIEW_CreateIndirect, NULL, ID_LISTVIEW_0, 0, 0, 775, 377, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};
/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
// USER START (Optionally insert additional static code)
// USER END
/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id,x;
  char    buf[4] ; 
  
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Устроййс'
    //
  hItem = pMsg->hWin;
  FRAMEWIN_SetTitleVis(hItem, 1);
  FRAMEWIN_SetTitleHeight(hItem, 37);
  FRAMEWIN_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
  FRAMEWIN_SetFont(hItem, &GUI_FontVerdana25);
    //
    // Initialization of 'Listview'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_LISTVIEW_0);
    HEADER_SetBkColor(LISTVIEW_GetHeader(hItem), GUI_RED);
    HEADER_SetFont(LISTVIEW_GetHeader(hItem), &GUI_FontVerdana23);
    LISTVIEW_AddColumn(hItem, 80, (const char *)&TextString82, GUI_TA_HCENTER | GUI_TA_VCENTER);    // "Адрес"
    LISTVIEW_AddColumn(hItem, 100,(const char *)&TextString83, GUI_TA_HCENTER | GUI_TA_VCENTER);    // "Тип"
    LISTVIEW_AddColumn(hItem, 80, (const char *)&TextString77, GUI_TA_HCENTER | GUI_TA_VCENTER);    // "Зона"
    LISTVIEW_AddColumn(hItem, 45, (const char *)&TextString318,GUI_TA_HCENTER | GUI_TA_VCENTER);   // "Акт"
    LISTVIEW_AddColumn(hItem, 80, "порог", GUI_TA_HCENTER | GUI_TA_VCENTER);   // "порог" 
    LISTVIEW_AddColumn(hItem, 185,(const char *)&TextString76, GUI_TA_HCENTER | GUI_TA_VCENTER);   // "состояние"   
    LISTVIEW_AddColumn(hItem, 205,(const char *)&TextString273,GUI_TA_HCENTER | GUI_TA_BOTTOM) ;   //"описание"
    LISTVIEW_SetGridVis(hItem, 1);
    LISTVIEW_SetAutoScrollV(hItem, 1);
    LISTVIEW_SetRowHeight(hItem, 25);
    LISTVIEW_SetHeaderHeight(hItem, 25);
    LISTVIEW_SetFont(hItem, &GUI_FontVerdana23);

    LISTVIEW_SetSel(hItem,0) ;
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
    case WM_KEY:    
                 switch (pMsg->Data.v)
                    {        
                      case GUI_KEY_ENTER_HAND :
                                                hItem= WM_GetDialogItem(pMsg->hWin, ID_LISTVIEW_0);     
                                                if (LISTVIEW_GetNumRows(hItem))
                                                {   
                                                   LISTVIEW_GetItemText(hItem,0, LISTVIEW_GetSel(hItem),(char*)&buf,4) ;                                     
                                                }                       
                                                break ; 
                      case GUI_KEY_UP_HAND   :  LISTVIEW_DecSel (WM_GetDialogItem(pMsg->hWin, ID_LISTVIEW_0));break ;                                                                                        
                      case GUI_KEY_DOWN_HAND :  LISTVIEW_IncSel (WM_GetDialogItem(pMsg->hWin, ID_LISTVIEW_0));break ; 
                      case GUI_KEY_F3_HAND   :  break ;   
                      case GUI_KEY_F2_HAND   :  break ; 
                      case GUI_KEY_LEFT_HAND :  GUI_EndDialog(pMsg->hWin,1)           ; break ;
                      case GUI_KEY_PGUP_HAND :  x=LISTVIEW_GetSel (WM_GetDialogItem(pMsg->hWin, ID_LISTVIEW_0)) ; 
                                                if (x<STEP_PG_DW)
                                                {
                                                  x=STEP_PG_DW ; 
                                                }
                                               LISTVIEW_SetSel (WM_GetDialogItem(pMsg->hWin, ID_LISTVIEW_0), (x-STEP_PG_DW)) ;
                                                break ; 
                      case GUI_KEY_PGDOWN_HAND: x=LISTVIEW_GetSel (WM_GetDialogItem(pMsg->hWin, ID_LISTVIEW_0) ); 
                                                LISTVIEW_SetSel (WM_GetDialogItem(pMsg->hWin, ID_LISTVIEW_0),(x+STEP_PG_DW)) ;
                                                break ;                            
                      case GUI_KEY_F1_HAND:     break ; 
                      case GUI_KEY_ESCAPE_HAND :GUI_EndDialog(pMsg->hWin,1)           ;                                                     
                                                break ;
                      default: break ;                          
                    }
                 break ;
  case WM_PRE_PAINT :
                   Fill_Table ( pMsg->hWin )                                 ;
                 break ;  
  case WM_PAINT : 
                   GUI_DrawGradientV ( 0, 0,  800 , 480, 0xFAE6E6, 0xEBCE87) ; 
     //             Print_Button_Row  ( 80 , 379 , 0)                         ;
                  
                   break ;
  case WM_POST_PAINT:  
                     if(!Cheak_Focus_Windows(WM_GetClientWindow(pMsg->hWin)))
                     {
                       if(Cheak_Cover_Windows_2(WM_GetClientWindow(pMsg->hWin)) )
                       {
                          WM_SetFocus(pMsg->hWin) ;   
                       }
                     }
                     break ; 
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_LISTVIEW_0: // Notifications sent by 'Listview'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_SEL_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
       case WM_NOTIFICATION_GOT_FOCUS :
                //    Fill_Table ( pMsg.hWin ) ;
          break ;  
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}
/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       
*/
WM_HWIN Create_Framewin_Polling_Device_IO_Menu_in_Slave_Single ( uint32_t Adr )
{
  WM_HWIN hWin;
  
  if ( Check_GUI_RAM ( ) )
  {
    hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN , 0 , 0 );
  }
  return hWin;
}
/** end **/


  /****************************************************************************
  * Имя функции   : Fill_Table
  * Описание      : заполняю таблицу 
  * 
  *
  * Параметры     : WM_HWIN 
  * Возврат       : нет
  ****************************************************************************/

static void  Fill_Table ( WM_HWIN hWin )   
{
 char *_aTable[1][7] ; 

  
  WM_HWIN hItem = WM_GetDialogItem(hWin, ID_LISTVIEW_0);
  uint32_t Sel= LISTVIEW_GetSel(hItem ) ;
  uint32_t Qty_Row= LISTVIEW_GetNumRows(hItem) ; 
  while(Qty_Row-.0)
  {
    LISTVIEW_DeleteRow(hItem,Qty_Row) ;       
  } 
  for ( uint16_t i = 1 ; i < MAX_QTY_ADR_IO ; ++i ) // отсчёт начинаю  с 1 элемента  тоесть с 1-го датчика 
  {   
    if ( !Check_GUI_RAM ( ) )
    {
      return ;
    }
    
   CLEAR_GuiCharArray ; 
    char Buf [ 5 ] ;
  ////////////////////////////////////////////////////////////////////////////
    //вывожу номер датчика 
    sprintf(GuiCharArray[0] , "%u",i)  ;
    _aTable[0][0]= (char*)&GuiCharArray[0];
  ////////////////////////////////////////////////////////////////////////////   
     //вывожу тип

    _aTable[0][1]= (char*)&GuiCharArray[1];  
  ////////////////////////////////////////////////////////////////////////////          
   //вывожу зону
   // sprintf(Buf,"%u",Get_Zona_Device_Slave ( AdresGlAI.AdrBky , AdresGlAI.AdrKL , i ) ) ;
    strcat(GuiCharArray[2], (char*)&Buf);              
    _aTable[0][2]= (char*)&GuiCharArray[2];  
  ///////////////////////////////////////////////////////////////////////////// 
    //определяю связь с устройством  
    _aTable[0][3]= (char*)&GuiCharArray[3];        
   /////////////////////////////////////////////////////////////////////////////  
    //вывожу Порог
  //  sprintf ( Buf , "%u", Get_ThresholdTemp_KLAI ( AdresGlAI.AdrKL , i) );
    strcat ( GuiCharArray [4], (char*)&Buf );              
    _aTable[0][4] = (char*)&GuiCharArray[4];  
    /////////////////////////////////////////////////////////////////////////////  
    //текущее состояние
    switch(1)      
    {
      case IPT_SIk_td : 
                         switch(1) // временное состояние 
                         {
                       //    case TypesTempCondIPT_AI_Dis        :  strcpy((char*)&GuiCharArray[5],(const char *)&TextString614)  ;break ; //"выключен"
                           case TypesTempCondIPT_AI_Fault      :  strcpy((char*)&GuiCharArray[5],(const char *)&TextString324)  ;break ; //"неисправен"
                           case TypesTempCondIPT_AI_Low_Voltage:  strcpy((char*)&GuiCharArray[5],(const char *)&TextString639)  ;break ; //"низкое напр."
                           case TypesTempCondIPT_AI_Norma      :  strcpy((char*)&GuiCharArray[5],(const char *)&TextString11)   ;break ; //"норма"
                           case TypesTempCondIPT_AI_Fire1      :  strcpy((char*)&GuiCharArray[5],(const char *)&TextString87)   ;break ; // "Внимание"
                           case TypesTempCondIPT_AI_Fire2      :  strcpy((char*)&GuiCharArray[5],(const char *)&TextString613)  ;break ; //"пожар"
                           case TypesTempCondIPT_AI_KZ         :  strcpy((char*)&GuiCharArray[5],(const char *)&TextString50)   ;break ; //"КЗ" 
               //            case  TOTAL_COND_ADR_NO_CONECTION   :  strcpy((char*)&GuiCharArray[5],(const char *)&TextString346)  ;break ; //"нет связи"
                          }
          
                        break ;
       default : break ; 
      }
    _aTable[0][5]= (char*)&GuiCharArray[5]; 
  /////////////////////////////////////////////////////////////////////////////  
  LISTVIEW_AddRow (hItem, _aTable[0]) ; 
 }   
 //Set_Sel_emWin(hItem ,Sel) ;         
}

   /** end **/
/*************************** End of file ****************************/